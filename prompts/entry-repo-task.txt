## TASK: Implement EntryRepository

Implement the EntryRepository class for user-defined sensitive data entries.

## DATABASE SCHEMA

```sql
CREATE TABLE user_entries (
    id                  INTEGER PRIMARY KEY AUTOINCREMENT,
    label               TEXT    NOT NULL UNIQUE,
    display_name        TEXT    NOT NULL,
    primary_value       TEXT    NOT NULL,
    classification      TEXT    NOT NULL DEFAULT 'ASK_FIRST'
        CHECK (classification IN ('NEVER_SHARE', 'ASK_FIRST', 'INTERNAL_ONLY', 'PUBLIC')),
    category            TEXT    NOT NULL DEFAULT 'general',
    notes               TEXT,
    is_active           INTEGER NOT NULL DEFAULT 1,
    created_at          TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at          TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
);

CREATE TABLE entry_variants (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    entry_id    INTEGER NOT NULL REFERENCES user_entries(id) ON DELETE CASCADE,
    variant_text TEXT   NOT NULL,
    created_at  TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    UNIQUE(entry_id, variant_text)
);
```

## TYPES

```typescript
import Database from 'better-sqlite3';

export enum ClassificationLevel {
  NEVER_SHARE = "NEVER_SHARE",
  ASK_FIRST = "ASK_FIRST",
  INTERNAL_ONLY = "INTERNAL_ONLY",
  PUBLIC = "PUBLIC",
}

export interface UserDefinedEntry {
  id: number;
  label: string;
  displayName: string;
  primaryValue: string;
  classification: ClassificationLevel;
  category: string;
  notes: string | null;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface EntryVariant {
  id: number;
  entryId: number;
  variantText: string;
  createdAt: string;
}

export interface CreateEntryInput {
  label: string;
  displayName: string;
  primaryValue: string;
  classification: ClassificationLevel;
  category?: string;
  notes?: string;
  variants?: string[];
}

export interface UpdateEntryInput {
  displayName?: string;
  primaryValue?: string;
  classification?: ClassificationLevel;
  category?: string;
  notes?: string;
  isActive?: boolean;
}

export interface EntryQueryFilter {
  category?: string;
  classification?: ClassificationLevel;
  isActive?: boolean;
  keyword?: string;
  limit?: number;
  offset?: number;
}

// Use RegistryError and RegistryErrorCode from pattern-repository
```

## METHODS TO IMPLEMENT

1. `create(input: CreateEntryInput): UserDefinedEntry` - Create entry + variants in transaction
2. `getById(id: number): (UserDefinedEntry & { variants: EntryVariant[] }) | null`
3. `getByLabel(label: string): (UserDefinedEntry & { variants: EntryVariant[] }) | null`
4. `update(id: number, input: UpdateEntryInput): UserDefinedEntry`
5. `deactivate(id: number): void`
6. `hardDelete(id: number): void`
7. `list(filter?: EntryQueryFilter): UserDefinedEntry[]`
8. `preloadForScanner(): Array<UserDefinedEntry & { variants: string[] }>`
9. `count(filter?: EntryQueryFilter): number`
10. `addVariant(entryId: number, variantText: string): EntryVariant`
11. `removeVariant(variantId: number): void`
12. `listVariants(entryId: number): EntryVariant[]`

## REQUIREMENTS

- Use transactions for create() since it inserts entry + variants
- Use prepared statements
- Handle UNIQUE constraint violations
- Convert snake_case to camelCase
- preloadForScanner should return entries with their variant texts as string array
- keyword filter in list() should search label, displayName, primaryValue

Output the complete EntryRepository class implementation with all imports.
